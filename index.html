<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MD转PDF工具</title>
    
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'PingFang SC', Arial, sans-serif;
            background: #f0f2f5;
            min-height: 100vh;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px;
            color: white;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .header h1 { font-size: 18px; margin-bottom: 12px; }
        .toolbar { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }
        
        .btn-export { background: #4CAF50; color: white; }
        .btn-preview { background: #2196F3; color: white; }
        .btn-clear { background: rgba(255,255,255,0.2); color: white; }
        
        .tabs { display: flex; background: white; border-bottom: 1px solid #e0e0e0; }
        
        .tab {
            flex: 1;
            padding: 14px;
            text-align: center;
            font-weight: 600;
            color: #666;
            border-bottom: 3px solid transparent;
            cursor: pointer;
        }
        
        .tab.active { color: #667eea; border-bottom-color: #667eea; }
        
        .content { display: none; }
        .content.active { display: block; }
        
        #editor {
            width: 100%;
            min-height: calc(100vh - 150px);
            padding: 15px;
            border: none;
            font-family: monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: none;
            outline: none;
        }
        
        #preview {
            padding: 20px;
            background: white;
            min-height: calc(100vh - 150px);
            line-height: 1.9;
        }
        
        #preview h1 { font-size: 1.6em; margin: 1em 0 0.5em; border-bottom: 2px solid #eee; padding-bottom: 0.3em; }
        #preview h2 { font-size: 1.4em; margin: 1em 0 0.5em; border-bottom: 1px solid #eee; padding-bottom: 0.2em; }
        #preview h3 { font-size: 1.2em; margin: 1em 0 0.5em; }
        #preview p { margin: 0.8em 0; }
        #preview strong { color: #333; }
        
        #preview table { border-collapse: collapse; width: 100%; margin: 1em 0; }
        #preview th, #preview td { border: 1px solid #ddd; padding: 8px 12px; text-align: left; }
        #preview th { background: #f5f5f5; }
        
        #preview code { background: #f5f5f5; padding: 2px 5px; border-radius: 3px; color: #e83e8c; }
        #preview pre { background: #282c34; color: #abb2bf; padding: 15px; border-radius: 8px; overflow-x: auto; margin: 1em 0; }
        #preview pre code { background: none; color: inherit; }
        
        #preview blockquote { border-left: 4px solid #667eea; padding: 10px 15px; background: #f9f9f9; margin: 1em 0; }
        #preview ul, #preview ol { margin: 0.8em 0; padding-left: 1.5em; }
        #preview li { margin: 0.3em 0; }
        #preview hr { border: none; border-top: 2px solid #eee; margin: 1.5em 0; }
        
        .math-block {
            margin: 1em 0;
            padding: 10px 5px;
            text-align: center;
            background: #f8f9fa;
            border-radius: 8px;
            overflow-x: auto;
        }
        
        .math-inline { display: inline; }
        .math-inline .katex { white-space: normal !important; }
        
        .boxed-answer {
            display: inline-block;
            border: 2px solid #667eea;
            padding: 8px 15px;
            border-radius: 6px;
            background: #f0f4ff;
            margin: 5px 0;
        }
        
        .katex { font-size: 1.1em; }
        .katex-display { margin: 0; overflow-x: auto; }
        
        @media print {
            .header, .tabs, #editPanel, .no-print { display: none !important; }
            #previewPanel { display: block !important; }
            #preview { padding: 0 !important; }
            .math-block { background: transparent !important; padding: 10px 0; }
            #preview h1, #preview h2, #preview h3 { page-break-after: avoid; }
            .math-block, #preview table, #preview pre { page-break-inside: avoid; }
            .math-inline .katex { white-space: normal !important; }
        }
        
        .tips { padding: 10px 15px; background: #e8f5e9; font-size: 12px; color: #2e7d32; }
    </style>
</head>
<body>
    <div class="header no-print">
        <h1> Markdown / LaTeX 转 PDF</h1>
        <div class="toolbar">
            <button class="btn-preview" onclick="switchTab('preview')"> 预览</button>
            <button class="btn-export" onclick="exportPDF()"> 保存PDF</button>
            <button class="btn-clear" onclick="clearAll()">️ 清空</button>
        </div>
    </div>
    
    <div class="tabs no-print">
        <div class="tab active" onclick="switchTab('edit')">✏️ 编辑</div>
        <div class="tab" onclick="switchTab('preview')"> 预览</div>
    </div>
    
    <div class="tips no-print">
        ✅ 已适配AI特殊公式格式，直接粘贴即可
    </div>
    
    <div id="editPanel" class="content active">
        <textarea id="editor" placeholder="直接粘贴AI生成的内容..."></textarea>
    </div>
    
    <div id="previewPanel" class="content">
        <div id="preview"></div>
    </div>

    <script>
        const editor = document.getElementById('editor');
        const preview = document.getElementById('preview');
        
        marked.setOptions({ breaks: true, gfm: true });
        
        function preprocessFormula(formula) {
            let f = formula.trim();
            
            f = f.replace(/\\text\s*\{([^}]*)\}/g, (match, content) => {
                if (content.includes('·')) {
                    let parts = content.split('·').map(p => p.trim()).filter(Boolean);
                    if (parts.length > 1) {
                        return parts.map(p => `\\text{${p}}`).join('\\cdot ');
                    }
                }
                return match;
            });
            
            f = f.replace(/·/g, '\\cdot ');
            f = f.replace(/\s+/g, ' ');
            f = f.replace(/\n/g, ' ');
            
            return f;
        }
        
        function renderKatex(formula, displayMode) {
            try {
                let f = preprocessFormula(formula);
                return katex.renderToString(f, {
                    displayMode: displayMode,
                    throwOnError: false,
                    strict: false
                });
            } catch (e) {
                console.warn('KaTeX error:', e.message);
                return `<code style="color:#d63384;background:#f8f0f4;padding:2px 6px;border-radius:4px;">${formula}</code>`;
            }
        }
        
        function isFormulaLine(line) {
            const trimmed = line.trim();
            if (!trimmed) return false;
            
            // 【核心修复】先去掉 \text{...} 内容，再检测中文
            // 这样 \text{常数} 不会导致整行被误判为非公式行
            const withoutText = trimmed.replace(/\\text\s*\{[^}]*\}/g, '');
            
            // 去掉\text后还包含中文字符，就不是纯公式行
            if (/[\u4e00-\u9fa5]/.test(withoutText)) return false;
            
            // 序号开头的行不是纯公式行
            if (/^[$（\[]\d+[$）\]]/.test(trimmed)) return false;
            if (/^\d+[\.、．\)]/.test(trimmed)) return false;
            
            // 纯英文单词开头（无LaTeX命令）不是公式行
            if (/^[a-zA-Z]/.test(trimmed) && !trimmed.includes('\\') && !/_/.test(trimmed) && !/\^/.test(trimmed)) {
                return false;
            }
            
            // 包含LaTeX命令的是公式行
            if (/\\(frac|text|sqrt|sum|prod|int|lambda|phi|alpha|beta|gamma|delta|Delta|theta|omega|pi|sigma|mu|nu|epsilon|rho|tau|chi|psi|Gamma|Omega|Lambda|Phi|Psi|Sigma|cos|sin|tan|log|ln|exp|lim|max|min|arccos|arcsin|arctan|cdot|times|div|pm|mp|leq|geq|neq|approx|equiv|infty|partial|nabla|vec|hat|bar|quad|qquad|left|right|boxed|mu_0|le|ge|Rightarrow|Leftarrow|rightarrow|leftarrow)\b/.test(trimmed)) {
                return true;
            }
            
            // 包含下标上标的是公式行
            if (/_\{[^}]+\}|\^\{[^}]+\}|_[a-zA-Z0-9]|\^[a-zA-Z0-9]/.test(trimmed)) return true;
            // 包含等号且有LaTeX特征的是公式行
            if (/=/.test(trimmed) && /[_^\\{}]/.test(trimmed)) return true;
            // 以反斜杠命令开头的是公式行
            if (/^\\[a-zA-Z]/.test(trimmed)) return true;
            
            return false;
        }
        
        function preprocessContent(text) {
            let lines = text.split('\n');
            let result = [];
            let i = 0;
            
            while (i < lines.length) {
                let line = lines[i];
                
                // 处理只有 $$ 结尾的情况
                if (line.trim() === '\\]') {
                    let formulaLines = [];
                    let j = result.length - 1;
                    
                    while (j >= 0) {
                        let prevLine = result[j];
                        if (prevLine.trim() === '' || prevLine.trim() === '---') break;
                        
                        // 【修复】检查是否为公式行时，也要排除\text中的中文
                        let prevWithoutText = prevLine.replace(/\\text\s*\{[^}]*\}/g, '');
                        if (/^(已知|设|由|根据|所以|因此|即|当|则|其中|代入|计算|先|再|最后|答案|解|证|注|提示)/.test(prevWithoutText.trim())) break;
                        if (/^[一二三四五六七八九十\d]+[、.．)]/.test(prevLine.trim())) break;
                        if (/^#+\s/.test(prevLine)) break;
                        // 如果去掉\text后还有中文，说明是描述性文字，不是公式
                        if (/[\u4e00-\u9fa5]/.test(prevWithoutText)) break;
                        
                        formulaLines.unshift(result.pop());
                        j--;
                    }
                    
                    if (formulaLines.length > 0) {
                        result.push('$$');
                        result.push(formulaLines.join('\n'));
                        result.push('$$');
                    }
                    i++;
                    continue;
                }
                
                // 检测纯公式行
                if (isFormulaLine(line) && !line.includes('$') && !line.trim().startsWith('\\[') && !line.trim().endsWith('\\]')) {
                    let formulaLines = [line];
                    let nextI = i + 1;
                    
                    while (nextI < lines.length) {
                        let nextLine = lines[nextI];
                        if (nextLine.trim() === '' || nextLine.trim() === '---') break;
                        if (nextLine.trim() === '\\]') { nextI++; break; }
                        if (isFormulaLine(nextLine) && !nextLine.includes('$')) {
                            formulaLines.push(nextLine);
                            nextI++;
                        } else break;
                    }
                    
                    let formula = formulaLines.join('\n');
                    let prevLine = result.length > 0 ? result[result.length - 1].trim() : '';
                    let isBlock = prevLine === '' || prevLine.endsWith('：') || prevLine.endsWith(':') || formulaLines.length > 1;
                    
                    if (isBlock) {
                        result.push('$$' + formula + '$$');
                    } else {
                        result.push('$' + formula + '$');
                    }
                    
                    i = nextI;
                    continue;
                }
                
                // 处理行内公式
                if (line.includes('\\') || line.includes('_') || /[a-zA-Z]\s*[<>=]\s*[a-zA-Z0-9]/.test(line)) {
                    line = processInlineFormulas(line);
                }
                
                result.push(line);
                i++;
            }
            
            return result.join('\n');
        }
        
        function processInlineFormulas(line) {
            // 如果已经有完整的$...$，跳过
            if (/\$[^$]+\$/.test(line)) return line;
            
            let result = line;
            
            function isInsideDollar(str, index) {
                let before = str.substring(0, index);
                return (before.match(/\$/g) || []).length % 2 === 1;
            }
            
            // 【修复】处理中文括号内的公式：（1\,\text{eV} = ...）
            result = result.replace(
                /（([^）]*\\[a-zA-Z][^）]*)）/g,
                (match, content, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    if (/\\[a-zA-Z]+/.test(content)) {
                        return '（$' + content.trim() + '$）';
                    }
                    return match;
                }
            );
            
            // 1. 处理包含 \Rightarrow 的连续推导表达式
            result = result.replace(
                /(\d+\s*=\s*(?:[^，。；\u4e00-\u9fa5⇒]|\\[a-zA-Z]+|\{[^}]*\})+\\Rightarrow(?:[^，。；\u4e00-\u9fa5]|\\[a-zA-Z]+|\{[^}]*\})+)/g,
                (match, p1, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + match.trim().replace(/[,，\s]+$/, '') + '$';
                }
            );
            
            // 2. 处理以\命令开头的复杂连续表达式
            result = result.replace(
                /(\\[a-zA-Z]+(?:\\[a-zA-Z]+|[a-zA-Z0-9_{}^]|\{[^}]*\})*\s*=\s*(?:[^，。；：\u4e00-\u9fa5]|\\[a-zA-Z]+|\{[^}]*\})+)/g,
                (match, p1, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + match.trim().replace(/[,，\s]+$/, '') + '$';
                }
            );
            
            // 3. 处理 变量 \approx 数值 单位
            result = result.replace(
                /([A-Za-z](?:_\{[^}]+\}|_[a-zA-Z0-9])?)\s*\\approx\s*([\d\.]+)\s*((?:\\,|\\\ |\\)?\s*\\text\{[^}]+\})/g,
                (match, variable, value, unit, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + variable + ' \\approx ' + value + ' ' + unit + '$';
                }
            );
            
            // 4. 处理 变量 = 数值 单位
            result = result.replace(
                /([A-Za-z](?:_\{[^}]+\}|_[a-zA-Z0-9])?)\s*=\s*([\d\.]+(?:\s*\\times\s*10\^[{\d}\-]+)?)\s*((?:\\,|\\\ |\\)?\s*\\text\{[^}]+\})/g,
                (match, variable, value, unit, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + variable + ' = ' + value + ' ' + unit + '$';
                }
            );
            
            // 5. 处理纯数字+单位
            result = result.replace(
                /(?<![a-zA-Z$=])(\d+(?:\.\d+)?(?:\s*\\times\s*10\^[{\d}\-]+)?)\s*((?:\\,|\\\ |\\)?\s*\\text\{[^}]+\})/g,
                (match, value, unit, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + value + unit + '$';
                }
            );
            
            // 6. 处理 k = 复杂表达式 形式
            result = result.replace(
                /(?<![a-zA-Z$])([a-zA-Z](?:_\{[^}]+\}|_[0-9])?)\s*=\s*((?:\\[a-zA-Z]+|[a-zA-Z0-9_{}^.,\s=]|\{[^}]*\})+?)(?=，|。|；|：|（|\(|[\u4e00-\u9fa5]|$)/g,
                (match, variable, expr, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    if (/[\\{}^_]/.test(expr)) {
                        return '$' + (variable + ' = ' + expr).trim().replace(/[,，\s]+$/, '') + '$';
                    }
                    return match;
                }
            );
            
            // 7. 处理简单等式：k=3, k=4 等
            result = result.replace(
                /(?<![a-zA-Z$\\])([a-zA-Z](?:_\{[^}]+\}|_[a-zA-Z0-9])?)\s*=\s*(-?\d+(?:\.\d+)?(?:\\?\^[{\d}]+)?)(?=[\s,，。；：\u4e00-\u9fa5]|$)(?!\s*\\)/g,
                (match, variable, value, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + variable + '=' + value + '$';
                }
            );
            
            // 8. 处理比较表达式
            result = result.replace(
                /(-?\d+|[a-zA-Z](?:_\{[^}]+\}|_[a-zA-Z0-9])?)\s*(\\(?:le|ge|leq|geq)|[<>])\s*(-?\d+|[a-zA-Z](?:_\{[^}]+\}|_[a-zA-Z0-9])?)(?:\s*(\\(?:le|ge|leq|geq)|[<>])\s*(-?\d+|[a-zA-Z](?:_\{[^}]+\}|_[a-zA-Z0-9])?))?(?=：|:|\s|,|，|。|$)/g,
                (match, v1, op1, v2, op2, v3, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    if (op2 && v3) {
                        return '$' + v1 + ' ' + op1 + ' ' + v2 + ' ' + op2 + ' ' + v3 + '$';
                    }
                    return '$' + v1 + ' ' + op1 + ' ' + v2 + '$';
                }
            );
            
            // 9. 【增强】处理希腊字母+下标（支持更多形式如 \lambda_m）
            result = result.replace(
                /(\\(?:lambda|phi|alpha|beta|gamma|delta|Delta|theta|omega|pi|sigma|mu|nu|epsilon|rho|tau|chi|psi|Gamma|Omega|Lambda|Phi|Psi|Sigma)(?:_[a-zA-Z0-9]|_\{[^}]+\})?)/g,
                (match, p1, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + match.trim() + '$';
                }
            );
            
            // 10. 【增强】处理 E_{\text{...}} 形式的复杂下标
            result = result.replace(
                /([A-Za-z]_\{\\text\{[^}]+\}\})/g,
                (match, p1, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + match.trim() + '$';
                }
            );
            
            // 11. 处理简单下标变量（如 U_s, T_1）
            result = result.replace(
                /(?<![a-zA-Z$\\])([A-Za-z]_[a-zA-Z0-9])(?=[\s,，。；：\u4e00-\u9fa5（）()]|$)/g,
                (match, p1, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + match.trim() + '$';
                }
            );
            
            // 12. 【新增】处理整个公式块（包含\quad\text{...}）
            result = result.replace(
                /([A-Za-z](?:_\{[^}]+\}|_[a-zA-Z0-9])?)\s*=\s*(\\frac\{[^}]+\}\{[^}]+\})\s*(\\quad\s*\\text\{[^}]+\})/g,
                (match, variable, frac, suffix, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + variable + ' = ' + frac + ' ' + suffix + '$';
                }
            );
            
            // 13. 【新增】处理包含三角函数的表达式
            result = result.replace(
                /([\d\.]+(?:×|\s*\\times\s*)10\^\{?-?\d+\}?\s*=\s*[\d\.]+(?:×|\s*\\times\s*)10\^\{?-?\d+\}?\s*\([^)]*\\cos[^)]*\))/g,
                (match, p1, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + match + '$';
                }
            );
            
            // 14. 【新增】处理角度单位：30.0^\circ
            result = result.replace(
                /(\d+(?:\.\d+)?)(\s*\^\\circ)/g,
                (match, number, angleUnit, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    // 检查前面是否有其他匹配模式
                    // 如果前面已经有$，或者这是更大表达式的一部分，则不处理
                    if (offset > 0 && result[offset-1] === '$') return match;
                    return '$' + number + angleUnit + '$';
                }
            );
            
            // 15. 后备处理：分数、花括号下标变量等
            const patterns = [
                /(\\frac\{[^}]+\}\{[^}]+\}(?:\s*\\quad\s*\\text\{[^}]+\})?)/g,
                /([A-Za-z]_\{[^}]+\}(?:\^[{\da-zA-Z}]+)?)/g,
            ];
            
            for (let pattern of patterns) {
                result = result.replace(pattern, (match, p1, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + match.trim() + '$';
                });
            }
            
            return result;
        }
        
        function updatePreview() {
            let content = editor.value;
            if (!content.trim()) {
                preview.innerHTML = '<p style="color:#999;text-align:center;padding:50px;">粘贴内容后点击预览</p>';
                return;
            }
            
            content = preprocessContent(content);
            
            const formulas = [];
            let idx = 0;
            
            function saveFormula(formula, isBlock, isBoxed) {
                formulas.push({ formula, isBlock, isBoxed });
                return `%%F${idx++}%%`;
            }
            
            content = content.replace(/\$\$([\s\S]*?)\$\$/g, (m, f) => saveFormula(f, true, false));
            content = content.replace(/\\\[([\s\S]*?)\\\]/g, (m, f) => saveFormula(f, true, false));
            content = content.replace(/\\\((.*?)\\\)/g, (m, f) => saveFormula(f, false, false));
            content = content.replace(/\$([^\$\n]+?)\$/g, (m, f) => saveFormula(f, false, false));
            content = content.replace(/\\boxed\{((?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*)\}/g, (m, f) => saveFormula(f, false, true));
            
            let html = marked.parse(content);
            
            html = html.replace(/%%F(\d+)%%/g, (m, i) => {
                const item = formulas[parseInt(i)];
                if (!item) return m;
                
                const rendered = renderKatex(item.formula, item.isBlock);
                
                if (item.isBoxed) {
                    return `<span class="boxed-answer">${rendered}</span>\u200B`;
                } else if (item.isBlock) {
                    return `<div class="math-block">${rendered}</div>`;
                } else {
                    return `<span class="math-inline">${rendered}</span>\u200B`;
                }
            });
            
            preview.innerHTML = html;
        }
        
        function switchTab(tab) {
            document.querySelectorAll('.tab').forEach((t, i) => {
                t.classList.toggle('active', (tab === 'edit' && i === 0) || (tab === 'preview' && i === 1));
            });
            document.getElementById('editPanel').classList.toggle('active', tab === 'edit');
            document.getElementById('previewPanel')。classList.toggle('active', tab === 'preview');
            if (tab === 'preview') updatePreview();
        }
        
        function exportPDF() {
            if (!editor.value.trim()) { alert('请先输入内容！'); return; }
            updatePreview();
            switchTab('preview');
            setTimeout(() => window.print(), 300);
        }
        
        function clearAll() {
            if (editor.value && !confirm('确定清空？')) return;
            editor.value = '';
            preview.innerHTML = '';
            switchTab('edit');
        }
    </script>
</body>
</html>
