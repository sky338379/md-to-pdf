<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI æ–‡æ¡£ / LaTeX è½¬ PDF å·¥å…·</title>
    
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    
    <style>
        /* CSS æ ·å¼éƒ¨åˆ†ä¿æŒä¸å˜ï¼Œç¡®ä¿äº†ç¾è§‚å’Œæ‰“å°å…¼å®¹æ€§ */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'PingFang SC', Arial, sans-serif;
            background: #f0f2f5;
            min-height: 100vh;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px;
            color: white;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .header h1 { font-size: 18px; margin-bottom: 12px; }
        .toolbar { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }
        
        .btn-export { background: #4CAF50; color: white; }
        .btn-preview { background: #2196F3; color: white; }
        .btn-clear { background: rgba(255,255,255,0.2); color: white; }
        
        .tabs { display: flex; background: white; border-bottom: 1px solid #e0e0e0; }
        
        .tab {
            flex: 1;
            padding: 14px;
            text-align: center;
            font-weight: 600;
            color: #666;
            border-bottom: 3px solid transparent;
            cursor: pointer;
        }
        
        .tab.active { color: #667eea; border-bottom-color: #667eea; }
        
        .content { display: none; }
        .content.active { display: block; }
        
        #editor {
            width: 100%;
            min-height: calc(100vh - 150px);
            padding: 15px;
            border: none;
            font-family: monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: none;
            outline: none;
        }
        
        #preview {
            padding: 20px;
            background: white;
            min-height: calc(100vh - 150px);
            line-height: 1.9;
        }
        
        #preview h1 { font-size: 1.6em; margin: 1em 0 0.5em; border-bottom: 2px solid #eee; padding-bottom: 0.3em; }
        #preview h2 { font-size: 1.4em; margin: 1em 0 0.5em; border-bottom: 1px solid #eee; padding-bottom: 0.2em; }
        #preview h3 { font-size: 1.2em; margin: 1em 0 0.5em; }
        #preview p { margin: 0.8em 0; }
        #preview strong { color: #333; }
        
        #preview table { border-collapse: collapse; width: 100%; margin: 1em 0; overflow-x: auto; display: block; /* å…è®¸æ‰‹æœºæ¨ªå‘æ»šåŠ¨ */ }
        #preview th, #preview td { border: 1px solid #ddd; padding: 8px 12px; text-align: left; }
        #preview th { background: #f5f5f5; }
        
        #preview code { background: #f5f5f5; padding: 2px 5px; border-radius: 3px; color: #e83e8c; }
        #preview pre { background: #282c34; color: #abb2bf; padding: 15px; border-radius: 8px; overflow-x: auto; margin: 1em 0; }
        #preview pre code { background: none; color: inherit; }
        
        #preview blockquote { border-left: 4px solid #667eea; padding: 10px 15px; background: #f9f9f9; margin: 1em 0; }
        #preview ul, #preview ol { margin: 0.8em 0; padding-left: 1.5em; }
        #preview li { margin: 0.3em 0; }
        #preview hr { border: none; border-top: 2px solid #eee; margin: 1.5em 0; }
        
        .math-block {
            margin: 1em 0;
            padding: 10px 5px;
            text-align: center;
            background: #f8f9fa;
            border-radius: 8px;
            overflow-x: auto;
        }
        
        .math-inline { display: inline; }
        .math-inline .katex { white-space: normal !important; }
        
        .boxed-answer {
            display: inline-block;
            border: 2px solid #667eea;
            padding: 8px 15px;
            border-radius: 6px;
            background: #f0f4ff;
            margin: 5px 0;
        }
        
        .katex { font-size: 1.1em; }
        .katex-display { margin: 0; overflow-x: auto; }
        
        @media print {
            .header, .tabs, #editPanel, .no-print { display: none !important; }
            #previewPanel { display: block !important; }
            #preview { padding: 0 !important; }
            .math-block { background: transparent !important; padding: 10px 0; }
            /* é¿å…åˆ†é¡µç¬¦å‡ºç°åœ¨æ ‡é¢˜å’Œå…¬å¼å—å†… */
            #preview h1, #preview h2, #preview h3 { page-break-after: avoid; }
            .math-block, #preview table, #preview pre { page-break-inside: avoid; }
            .math-inline .katex { white-space: normal !important; }
        }
        
        .tips { padding: 10px 15px; background: #e8f5e9; font-size: 12px; color: #2e7d32; }
    </style>
</head>
<body>
    <div class="header no-print">
        <h1> Markdown / LaTeX è½¬ PDF</h1>
        <div class="toolbar">
            <button class="btn-preview" onclick="switchTab('preview')"> é¢„è§ˆ</button>
            <button class="btn-export" onclick="exportPDF()"> ä¿å­˜PDF</button>
            <button class="btn-clear" onclick="clearAll()">ï¸ æ¸…ç©º</button>
        </div>
    </div>
    
    <div class="tabs no-print">
        <div class="tab active" onclick="switchTab('edit')">âœï¸ ç¼–è¾‘</div>
        <div class="tab" onclick="switchTab('preview')"> é¢„è§ˆ</div>
    </div>
    
    <div class="tips no-print">
        âœ… å·²é€‚é…AIç‰¹æ®Šå…¬å¼æ ¼å¼ï¼Œç›´æ¥ç²˜è´´å³å¯
    </div>
    
    <div id="editPanel" class="content active">
        <textarea id="editor" placeholder="ç›´æ¥ç²˜è´´AIç”Ÿæˆçš„å†…å®¹..." oninput="saveDraft()"></textarea>
    </div>
    
    <div id="previewPanel" class="content">
        <div id="preview"></div>
    </div>

    <script>
        const editor = document.getElementById('editor');
        const preview = document.getElementById('preview');
        const editPanel = document.getElementById('editPanel');
        const previewPanel = document.getElementById('previewPanel');

        // --- åˆå§‹åŒ–è®¾ç½® ---
        marked.setOptions({ breaks: true, gfm: true });

        // å°è¯•åŠ è½½è‰ç¨¿
        window.onload = function() {
            const draft = localStorage.getItem('ai_md_draft');
            if (draft) {
                editor.value = draft;
            }
            // ç¡®ä¿ç¼–è¾‘æ¨¡å¼æ˜¯æ¿€æ´»çš„
            switchTab('edit', true); 
        };

        function saveDraft() {
            localStorage.setItem('ai_md_draft', editor.value);
        }

        // --- å…¬å¼é¢„å¤„ç†ï¼šä¿®å¤AIå¸¸çŠ¯çš„æ ¼å¼é”™è¯¯ ---
        function preprocessFormula(formula) {
            let f = formula.trim();
            
            f = f.replace(/\\text\s*\{([^}]*)\}/g, (match, content) => {
                if (content.includes('Â·')) {
                    let parts = content.split('Â·').map(p => p.trim()).filter(Boolean);
                    if (parts.length > 1) {
                        return parts.map(p => `\\text{${p}}`).join('\\cdot ');
                    }
                }
                return match;
            });
            
            f = f.replace(/Â·/g, '\\cdot ');
            f = f.replace(/\s+/g, ' ');
            f = f.replace(/\n/g, ' ');
            
            return f;
        }
        
        // --- KaTeX æ¸²æŸ“å‡½æ•° ---
        function renderKatex(formula, displayMode) {
            try {
                let f = preprocessFormula(formula);
                return katex.renderToString(f, {
                    displayMode: displayMode,
                    throwOnError: false,
                    strict: false
                });
            } catch (e) {
                console.warn('KaTeX error:', e.message);
                return `<code style="color:#d63384;background:#f8f0f4;padding:2px 6px;border-radius:4px;">${formula}</code>`;
            }
        }
        
        // --- å¤æ‚çš„è¡Œå…¬å¼æ£€æµ‹é€»è¾‘ï¼ˆæœªæ”¹åŠ¨ï¼‰ ---
        function isFormulaLine(line) {
            const trimmed = line.trim();
            if (!trimmed) return false;
            
            const withoutText = trimmed.replace(/\\text\s*\{[^}]*\}/g, '');
            
            if (/[\u4e00-\u9fa5]/.test(withoutText)) return false;
            if (/^[$ï¼ˆ\[]\d+[$ï¼‰\]]/.test(trimmed)) return false;
            if (/^\d+[\.ã€ï¼\)]/.test(trimmed)) return false;
            
            if (/^[a-zA-Z]/.test(trimmed) && !trimmed.includes('\\') && !/_/.test(trimmed) && !/\^/.test(trimmed)) {
                return false;
            }
            
            if (/\\(frac|text|sqrt|sum|prod|int|lambda|phi|alpha|beta|gamma|delta|Delta|theta|omega|pi|sigma|mu|nu|epsilon|rho|tau|chi|psi|Gamma|Omega|Lambda|Phi|Psi|Sigma|cos|sin|tan|log|ln|exp|lim|max|min|arccos|arcsin|arctan|cdot|times|div|pm|mp|leq|geq|neq|approx|equiv|infty|partial|nabla|vec|hat|bar|quad|qquad|left|right|boxed|mu_0|le|ge|Rightarrow|Leftarrow|rightarrow|leftarrow)\b/.test(trimmed)) {
                return true;
            }
            
            if (/_\{[^}]+\}|\^\{[^}]+\}|_[a-zA-Z0-9]|\^[a-zA-Z0-9]/.test(trimmed)) return true;
            if (/=/.test(trimmed) && /[_^\\{}]/.test(trimmed)) return true;
            if (/^\\[a-zA-Z]/.test(trimmed)) return true;
            
            return false;
        }
        
        // --- é¢„å¤„ç†å†…å®¹ï¼Œè‡ªåŠ¨æ·»åŠ  $$ ç•Œå®šç¬¦ï¼ˆæœªæ”¹åŠ¨ï¼‰ ---
        function preprocessContent(text) {
            let lines = text.split('\n');
            let result = [];
            let i = 0;
            
            while (i < lines.length) {
                let line = lines[i];
                
                // å¤„ç†åªæœ‰ $$ ç»“å°¾çš„æƒ…å†µ
                if (line.trim() === '\\]') {
                    let formulaLines = [];
                    let j = result.length - 1;
                    
                    while (j >= 0) {
                        let prevLine = result[j];
                        if (prevLine.trim() === '' || prevLine.trim() === '---') break;
                        
                        let prevWithoutText = prevLine.replace(/\\text\s*\{[^}]*\}/g, '');
                        if (/^(å·²çŸ¥|è®¾|ç”±|æ ¹æ®|æ‰€ä»¥|å› æ­¤|å³|å½“|åˆ™|å…¶ä¸­|ä»£å…¥|è®¡ç®—|å…ˆ|å†|æœ€å|ç­”æ¡ˆ|è§£|è¯|æ³¨|æç¤º)/.test(prevWithoutText.trim())) break;
                        if (/^[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹å\d]+[ã€.ï¼)]/.test(prevLine.trim())) break;
                        if (/^#+\s/.test(prevLine)) break;
                        if (/[\u4e00-\u9fa5]/.test(prevWithoutText)) break;
                        
                        formulaLines.unshift(result.pop());
                        j--;
                    }
                    
                    if (formulaLines.length > 0) {
                        result.push('$$');
                        result.push(formulaLines.join('\n'));
                        result.push('$$');
                    }
                    i++;
                    continue;
                }
                
                // æ£€æµ‹çº¯å…¬å¼è¡Œ
                if (isFormulaLine(line) && !line.includes('$') && !line.trim().startsWith('\\[') && !line.trim().endsWith('\\]')) {
                    let formulaLines = [line];
                    let nextI = i + 1;
                    
                    while (nextI < lines.length) {
                        let nextLine = lines[nextI];
                        if (nextLine.trim() === '' || nextLine.trim() === '---') break;
                        if (nextLine.trim() === '\\]') { nextI++; break; }
                        if (isFormulaLine(nextLine) && !nextLine.includes('$')) {
                            formulaLines.push(nextLine);
                            nextI++;
                        } else break;
                    }
                    
                    let formula = formulaLines.join('\n');
                    let prevLine = result.length > 0 ? result[result.length - 1].trim() : '';
                    let isBlock = prevLine === '' || prevLine.endsWith('ï¼š') || prevLine.endsWith(':') || formulaLines.length > 1;
                    
                    if (isBlock) {
                        result.push('$$' + formula + '$$');
                    } else {
                        result.push('$' + formula + '$');
                    }
                    
                    i = nextI;
                    continue;
                }
                
                // å¤„ç†è¡Œå†…å…¬å¼
                if (line.includes('\\') || line.includes('_') || /[a-zA-Z]\s*[<>=]\s*[a-zA-Z0-9]/.test(line)) {
                    line = processInlineFormulas(line);
                }
                
                result.push(line);
                i++;
            }
            
            return result.join('\n');
        }
        
        // --- è¡Œå†…å…¬å¼è‡ªåŠ¨åŒ…è£¹é€»è¾‘ï¼ˆæœªæ”¹åŠ¨ï¼‰ ---
        function processInlineFormulas(line) {
            if (/\$[^$]+\$/.test(line)) return line;
            
            let result = line;
            
            function isInsideDollar(str, index) {
                let before = str.substring(0, index);
                return (before.match(/\$/g) || []).length % 2 === 1;
            }
            
            result = result.replace(
                /ï¼ˆ([^ï¼‰]*\\[a-zA-Z][^ï¼‰]*)ï¼‰/g,
                (match, content, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    if (/\\[a-zA-Z]+/.test(content)) {
                        return 'ï¼ˆ$' + content.trim() + '$ï¼‰';
                    }
                    return match;
                }
            );
            
            result = result.replace(
                /(\d+\s*=\s*(?:[^ï¼Œã€‚ï¼›\u4e00-\u9fa5â‡’]|\\[a-zA-Z]+|\{[^}]*\})+\\Rightarrow(?:[^ï¼Œã€‚ï¼›\u4e00-\u9fa5]|\\[a-zA-Z]+|\{[^}]*\})+)/g,
                (match, p1, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + match.trim().replace(/[,ï¼Œ\s]+$/, '') + '$';
                }
            );
            
            result = result.replace(
                /(\\[a-zA-Z]+(?:\\[a-zA-Z]+|[a-zA-Z0-9_{}^]|\{[^}]*\})*\s*=\s*(?:[^ï¼Œã€‚ï¼›ï¼š\u4e00-\u9fa5]|\\[a-zA-Z]+|\{[^}]*\})+)/g,
                (match, p1, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + match.trim().replace(/[,ï¼Œ\s]+$/, '') + '$';
                }
            );
            
            result = result.replace(
                /([A-Za-z](?:_\{[^}]+\}|_[a-zA-Z0-9])?)\s*\\approx\s*([\d\.]+)\s*((?:\\,|\\\ |\\)?\s*\\text\{[^}]+\})/g,
                (match, variable, value, unit, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + variable + ' \\approx ' + value + ' ' + unit + '$';
                }
            );
            
            result = result.replace(
                /([A-Za-z](?:_\{[^}]+\}|_[a-zA-Z0-9])?)\s*=\s*([\d\.]+(?:\s*\\times\s*10\^[{\d}\-]+)?)\s*((?:\\,|\\\ |\\)?\s*\\text\{[^}]+\})/g,
                (match, variable, value, unit, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + variable + ' = ' + value + ' ' + unit + '$';
                }
            );
            
            result = result.replace(
                /(?<![a-zA-Z$=])(\d+(?:\.\d+)?(?:\s*\\times\s*10\^[{\d}\-]+)?)\s*((?:\\,|\\\ |\\)?\s*\\text\{[^}]+\})/g,
                (match, value, unit, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + value + unit + '$';
                }
            );
            
            result = result.replace(
                /(?<![a-zA-Z$])([a-zA-Z](?:_\{[^}]+\}|_[0-9])?)\s*=\s*((?:\\[a-zA-Z]+|[a-zA-Z0-9_{}^.,\s=]|\{[^}]*\})+?)(?=ï¼Œ|ã€‚|ï¼›|ï¼š|ï¼ˆ|\(|[\u4e00-\u9fa5]|$)/g,
                (match, variable, expr, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    if (/[\\{}^_]/.test(expr)) {
                        return '$' + (variable + ' = ' + expr).trim().replace(/[,ï¼Œ\s]+$/, '') + '$';
                    }
                    return match;
                }
            );
            
            result = result.replace(
                /(?<![a-zA-Z$\\])([a-zA-Z](?:_\{[^}]+\}|_[a-zA-Z0-9])?)\s*=\s*(-?\d+(?:\.\d+)?(?:\\?\^[{\d}]+)?)(?=[\s,ï¼Œã€‚ï¼›ï¼š\u4e00-\u9fa5]|$)(?!\s*\\)/g,
                (match, variable, value, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + variable + '=' + value + '$';
                }
            );
            
            result = result.replace(
                /(-?\d+|[a-zA-Z](?:_\{[^}]+\}|_[a-zA-Z0-9])?)\s*(\\(?:le|ge|leq|geq)|[<>])\s*(-?\d+|[a-zA-Z](?:_\{[^}]+\}|_[a-zA-Z0-9])?)(?:\s*(\\(?:le|ge|leq|geq)|[<>])\s*(-?\d+|[a-zA-Z](?:_\{[^}]+\}|_[a-zA-Z0-9])?))?(?=ï¼š|:|\s|,|ï¼Œ|ã€‚|$)/g,
                (match, v1, op1, v2, op2, v3, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    if (op2 && v3) {
                        return '$' + v1 + ' ' + op1 + ' ' + v2 + ' ' + op2 + ' ' + v3 + '$';
                    }
                    return '$' + v1 + ' ' + op1 + ' ' + v2 + '$';
                }
            );
            
            result = result.replace(
                /(\\(?:lambda|phi|alpha|beta|gamma|delta|Delta|theta|omega|pi|sigma|mu|nu|epsilon|rho|tau|chi|psi|Gamma|Omega|Lambda|Phi|Psi|Sigma)(?:_[a-zA-Z0-9]|_\{[^}]+\})?)/g,
                (match, p1, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + match.trim() + '$';
                }
            );
            
            result = result.replace(
                /([A-Za-z]_\{\\text\{[^}]+\}\})/g,
                (match, p1, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + match.trim() + '$';
                }
            );
            
            result = result.replace(
                /(?<![a-zA-Z$\\])([A-Za-z]_[a-zA-Z0-9])(?=[\s,ï¼Œã€‚ï¼›ï¼š\u4e00-\u9fa5ï¼ˆï¼‰()]|$)/g,
                (match, p1, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + match.trim() + '$';
                }
            );
            
            result = result.replace(
                /([A-Za-z](?:_\{[^}]+\}|_[a-zA-Z0-9])?)\s*=\s*(\\frac\{[^}]+\}\{[^}]+\})\s*(\\quad\s*\\text\{[^}]+\})/g,
                (match, variable, frac, suffix, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + variable + ' = ' + frac + ' ' + suffix + '$';
                }
            );
            
            result = result.replace(
                /([\d\.]+(?:Ã—|\s*\\times\s*)10\^\{?-?\d+\}?\s*=\s*[\d\.]+(?:Ã—|\s*\\times\s*)10\^\{?-?\d+\}?\s*\([^)]*\\cos[^)]*\))/g,
                (match, p1, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + match + '$';
                }
            );
            
            result = result.replace(
                /(\d+(?:\.\d+)?)(\s*\^\\circ)/g,
                (match, number, angleUnit, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    if (offset > 0 && result[offset-1] === '$') return match;
                    return '$' + number + angleUnit + '$';
                }
            );
            
            const patterns = [
                /(\\frac\{[^}]+\}\{[^}]+\}(?:\s*\\quad\s*\\text\{[^}]+\})?)/g,
                /([A-Za-z]_\{[^}]+\}(?:\^[{\da-zA-Z}]+)?)/g,
            ];
            
            for (let pattern of patterns) {
                result = result.replace(pattern, (match, p1, offset) => {
                    if (isInsideDollar(result, offset)) return match;
                    return '$' + match.trim() + '$';
                });
            }
            
            return result;
        }
        
        // --- é¢„è§ˆæ›´æ–°å‡½æ•° ---
        function updatePreview() {
            let content = editor.value;
            if (!content.trim()) {
                preview.innerHTML = '<p style="color:#999;text-align:center;padding:50px;">ç²˜è´´å†…å®¹åç‚¹å‡»é¢„è§ˆ</p>';
                return;
            }
            
            content = preprocessContent(content);
            
            const formulas = [];
            let idx = 0;
            
            function saveFormula(formula, isBlock, isBoxed) {
                formulas.push({ formula, isBlock, isBoxed });
                return `%%F${idx++}%%`;
            }
            
            content = content.replace(/\$\$([\s\S]*?)\$\$/g, (m, f) => saveFormula(f, true, false));
            content = content.replace(/\\\[([\s\S]*?)\\\]/g, (m, f) => saveFormula(f, true, false));
            content = content.replace(/\\\((.*?)\\\)/g, (m, f) => saveFormula(f, false, false));
            content = content.replace(/\$([^\$\n]+?)\$/g, (m, f) => saveFormula(f, false, false));
            content = content.replace(/\\boxed\{((?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*)\}/g, (m, f) => saveFormula(f, false, true));
            
            let html = marked.parse(content);
            
            html = html.replace(/%%F(\d+)%%/g, (m, i) => {
                const item = formulas[parseInt(i)];
                if (!item) return m;
                
                const rendered = renderKatex(item.formula, item.isBlock);
                
                if (item.isBoxed) {
                    return `<span class="boxed-answer">${rendered}</span>\u200B`;
                } else if (item.isBlock) {
                    return `<div class="math-block">${rendered}</div>`;
                } else {
                    return `<span class="math-inline">${rendered}</span>\u200B`;
                }
            });
            
            preview.innerHTML = html;
        }
        
        // --- æ ‡ç­¾é¡µåˆ‡æ¢å‡½æ•°ï¼ˆå·²ä¿®å¤ä¸­æ–‡å¥å·é”™è¯¯ï¼‰ ---
        function switchTab(tab, initial = false) {
            document.querySelectorAll('.tab').forEach((t, i) => {
                t.classList.toggle('active', (tab === 'edit' && i === 0) || (tab === 'preview' && i === 1));
            });
            editPanel.classList.toggle('active', tab === 'edit');
            // ğŸš¨ é”™è¯¯ä¿®å¤ç‚¹ï¼šå°†ä¸­æ–‡å¥å· `ã€‚` æ›¿æ¢ä¸ºè‹±æ–‡å¥ç‚¹ `.`
            previewPanel.classList.toggle('active', tab === 'preview'); 
            
            if (tab === 'preview' && !initial) updatePreview();
        }
        
        // --- å¯¼å‡º PDF å‡½æ•° ---
        function exportPDF() {
            if (!editor.value.trim()) { alert('è¯·å…ˆè¾“å…¥å†…å®¹ï¼'); return; }
            updatePreview();
            switchTab('preview');
            // å»¶è¿Ÿæ‰“å°ï¼Œç¡®ä¿å…¬å¼å’Œå›¾ç‰‡å®Œæˆæ¸²æŸ“
            setTimeout(() => window.print(), 300); 
        }
        
        // --- æ¸…ç©ºå‡½æ•° ---
        function clearAll() {
            if (editor.value && !confirm('ç¡®å®šæ¸…ç©ºï¼Ÿ')) return;
            editor.value = '';
            preview.innerHTML = '';
            localStorage.removeItem('ai_md_draft'); // æ¸…ç©ºè‰ç¨¿
            switchTab('edit');
        }
    </script>
</body>
</html>
